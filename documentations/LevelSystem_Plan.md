# Generated by SuperbulletAI (and how it planned to make it, feel free to delete this)

---

# Level System (Server + Client) - Design Plan

This plan outlines a modular, configurable Level/Rebirth system with UI and studio tester parts, fully integrated with existing ProfileService + DataController.

## Table of Contents

- [Key Goals](#key-goals)
- [Architecture Overview (Knit)](#architecture-overview-knit)
  - [Data Flow (Authoritative)](#data-flow-authoritative)
- [Data Model in ProfileTemplate](#data-model-in-profiletemplate)
  - [Notes](#notes)
- [Server Methods](#server-methods-server-authoritative-no-client-write-rpc)
- [Server Component Responsibilities](#server-component-responsibilities)
- [Client UI Requirements](#client-ui-requirements)
- [Testing Parts (Server)](#testing-parts-server)
- [Security & Validation](#security--validation)
- [Files To Create](#files-to-create)
- [Phases](#phases)
- [Security Model](#security-model)
- [Configuration Schema (high-level)](#configuration-schema-high-level)
  - [How to add a new level type](#how-to-add-a-new-level-type)
  - [How to change/disable rebirths](#how-to-changedisable-rebirths)
- [Scaling Formulas (concept)](#scaling-formulas-concept)
- [Profile Integration Details](#profile-integration-details)
- [Client Reading via DataController (example)](#client-reading-via-datacontroller-example)
- [UI Specification (read-only)](#ui-specification-read-only)
- [Studio Tester Parts (server)](#studio-tester-parts-server)
- [Extension Points](#extension-points)
- [Acceptance Criteria](#acceptance-criteria)
- [Out of Scope (for now)](#out-of-scope-for-now)
- [Framework Constraints](#framework-constraints)
- [Open Questions](#open-questions)

## Key Goals

- Configurable naming (EXP name, Level name, Rebirth name), optional rebirth feature
- Pluggable multiple level types (e.g., Levels, Ranks, Stages, Tiers); you can add more easily
- Pluggable multiple rebirth types, with mapping to level type(s)
- Scaling formula is data-driven and swappable at runtime
- ProfileService integration via ProfileTemplate and DataController streaming
- Client UI (progress bar, exp text, current level), multi-type aware, closable
- Server tester parts in Workspace with 1s cooldown: +1 EXP, +100 EXP, +EnoughToLevel, -1 EXP, Set EXP

## Architecture Overview (Knit)

### Data Flow (Authoritative)

- Server-only changes update ProfileService via ProfileService:ChangeData (through LevelService components).
- ProfileService pushes initial and delta updates: Client.GetData and Client.UpdateSpecificData.
- DataController receives those updates and maintains DataController.Data.
- UI reads DataController.Data to render level name, EXP, MaxExp, and rebirth counts.
- No client RPCs for writes; server remains authoritative.

- Server: LevelService

  - Remotes: No client write endpoints. UI mirrors data via DataController.
  - Components:
    - Get(): read-only queries (current exp/level, next max exp, names)
    - Set(): write ops (grant exp, set exp, set level, set rebirth), input validation + rate limiting
    - Others/:
      - Config.lua: centralized configuration (names, toggles, level/rebirth types, mappings)
      - Formulas.lua: scaling strategies registry (linear, exponential, curve), easily extendable
      - Calculator.lua: business logic for exp add/remove, level ups, overflow handling, multi-type support
      - BridgeProfile.lua: reads/writes ProfileService with safe pathing and UpdateSpecificData firing
      - Cooldowns.lua: server-only cooldown helper for tester parts
      - Validators.lua: type/range validation, whitelist for level/rebirth types

- Client: LevelController
  - Components:
    - Get(): compute UI state from DataController.Data (profile mirror)
    - Set(): client-side UI show/hide; ask server for actions if needed (rare)
    - Others/:
      - UIBuilder.lua: build ScreenGui + ProgressBar (structure only if prebuilt) or bind to existing UI
      - UIState.lua: maps profile data to UI text/percent
      - Formatter.lua: uses Utilities.Number.AddCommasToNumbers if present

## Data Model in ProfileTemplate

**ProfileTemplate is AUTO-GENERATED from LevelingConfig!**

The `Leveling` section is automatically built using `BuildProfileTemplate_ForLevel.GenerateLevelingData()`, which:

- Reads all types from `LevelingConfig.Types`
- Calculates correct base MaxExp for each type using `GetBaseMaxExp`
- Initializes Types and Rebirths tables automatically

**To add a new level type:** Just add it to `LevelingConfig.Types` - ProfileTemplate will auto-populate!

Generated structure example:

```lua
Leveling = {
  -- Auto-generated from LevelingConfig.Types
  Types = {
    levels = { Exp = 0, Level = 1, MaxExp = 100 },  -- Calculated from formula
    ranks  = { Exp = 0, Level = 1, MaxExp = 50  },  -- Calculated from formula
    stages = { Exp = 0, Level = 1, MaxExp = 200 },  -- Calculated from formula
    tiers  = { Exp = 0, Level = 1, MaxExp = 100 },  -- Calculated from formula
  },
  Rebirths = {
    levels = 0,  -- Auto-initialized for each type
    ranks  = 0,
    stages = 0,
    tiers  = 0,
  },
}
```

### Notes

- Display names (`Name`, `ExpName`) live in `ReplicatedStorage.SharedSource.Datas.LevelingConfig.Types`, not in the profile.
- Add/remove level types by editing both `ProfileTemplate.Leveling.Types` (for save data) and `LevelingConfig.Types` (for display + scaling).
- Rebirth counters are stored per levelType in `ProfileTemplate.Leveling.Rebirths[levelType]`.
- Mapping to rebirth families and enable/disable live in `LevelingConfig.Rebirths`.

## Server Methods (server-authoritative; no client write RPC)

- **LevelService:AddExp(player, amount, levelType)** â€” Adds EXP to the given `levelType`. Updates `Exp`, `Level`, and `MaxExp` using the per-type formula from `LevelingConfig`.
- **LevelService:GetAllTypesData(player)** â€” Returns a table keyed by `levelType` with `{ Exp, Level, MaxExp, Rebirths, Name, ExpName }`.
- **LevelService:AddRebirth(player, amount, levelType)** â€” Increments rebirth counter by amount (can be negative to decrease).
- **LevelService:ResetLevel(player, levelType)** â€” Resets level and EXP to starting values (keeps rebirth count).
- **LevelService:SetRebirthCount(player, count, levelType)** â€” Sets rebirth count directly (for testing/admin purposes).
- No LevelService.Client write methods; UI derives all display data from `DataController.Data` (and may use `LevelingConfig` for names if needed).
- No client endpoints for modifying EXP/Level/Rebirths. All adjustments occur server-side (tester parts, game events, admin tools).

## Server Component Responsibilities

- Components/Get().lua
  - Read-only queries via `ProfileService:GetProfile`; returns all type data with display names merged from config
- Components/Set().lua
  - Write operations (AddExp) via `ProfileService:ChangeData` with path arrays
- Others/Calculator.lua
  - Compute EXP additions, level-up loop, overflow carry
  - `ResolveFormulaParams(globalFormulas, typeScalingConfig)`: Implements fallback hierarchy (inline params > global formulas > default)
  - `GetNextMaxExp(formulaParams, level)`: Computes next MaxExp using resolved formula parameters
  - `AddExp(exp, maxExp, level, addAmount, formulaParams)`: Processes EXP gain with level-up overflow handling
- Shared Config (`ReplicatedStorage.SharedSource.Datas.LevelingConfig`)
  - Holds display names, rebirth families and map, and the global formulas library

## Client UI Requirements

- Progress bar, numeric exp/current/max, shown type name (e.g., Rank 3)
- Closeable toggle (persist last open state in profile? optional)
- Multi-type aware: either pick a default type to display (e.g., `levels`) or provide tabs/selectors. Names can be read from `LevelingConfig.Types[levelType]`.

## Testing Parts (Server)

- Planned: Create 5 parts under `Workspace/LevelSystem_Testers`
- Touch to trigger: +1, +100, +EnoughToLevel, -1, SetEXP (ProximityPrompt or Touch, with per-player cooldown)
- Implement via a server-side script calling `LevelService:AddExp` and writing via `ProfileService` where needed

## Security & Validation

- No client write endpoints exist; UI only reads mirrored data via DataController.
- All server-triggered adjustments validate amount range [-1e6..1e6], integers preferred.
- LevelType must exist in config; deny otherwise.
- 1s per-player cooldown enforcement for tester parts

## Files (current and planned)

- Server (implemented): `src/ServerScriptService/ServerSource/Server/LevelService/init.lua`
  - Components: `Get().lua`, `Set().lua`
  - Others: `Calculator.lua`
- Shared Data (implemented):
  - `src/ReplicatedStorage/SharedSource/Datas/ProfileTemplate.lua`
  - `src/ReplicatedStorage/SharedSource/Datas/LevelingConfig.lua`
- Shared Utilities (implemented):
  - `src/ReplicatedStorage/SharedSource/Utilities/Levels/GetBaseMaxExp.lua` - Calculate base MaxExp for level types
  - `src/ReplicatedStorage/SharedSource/Utilities/Levels/ProfileSeeder.lua` - Initialize/validate profile level types
  - `src/ReplicatedStorage/SharedSource/Utilities/Levels/BuildProfileTemplate_ForLevel.lua` - Auto-generate ProfileTemplate from config
- Client (existing infra): `DataController` streams profile data; a dedicated `LevelController` is optional/planned
- UI: build/bind a ScreenGui that reads from `DataController`
- Tester Parts (implemented): `src/ServerScriptService/ServerSource/Server/LevelSystemTesters.server.lua`

## Phases

1. Implement LevelService (Get/AddExp), `Calculator`, ProfileTemplate + LevelingConfig âœ…
2. Add tester parts and optional server cooldowns/validators
3. Add client controller/UI that reads `DataController` and `LevelingConfig`
4. Polishing: rebirth behaviors, extra formulas

Please review and approve. After approval, phases will be queued and executed one by one.

---

## Security Model

- No client write endpoints: the client never requests EXP/Level/Rebirth changes.
- All authoritative changes occur on the server (tester parts, gameplay systems, admin tools).
- UI mirrors data using the existing DataController stream from ProfileService.
- All inputs (server-triggered) are validated in Set() and guarded by cooldowns to prevent spam.

## Configuration Schema (high-level)

Configuration lives in `ReplicatedStorage.SharedSource.Datas.LevelingConfig` and exposes:

```lua
-- Pseudocode schema for documentation only
LevelingConfig = {
  Types = {
    -- Add/remove freely; display-facing names and per-type scaling
    -- Scaling supports TWO patterns:
    --   1) Reference a global formula by name (uses global params)
    --   2) Provide inline custom parameters (overrides global)

    -- Standard type using global Linear formula (Base=100, Increment=25)
    levels = {
      Name = "Level",
      ExpName = "EXP",
      RebirthType = "rebirth",  -- Which rebirth type to use (set to nil to disable)
      Scaling = { Formula = "Linear" }
    },

    -- Standard type using global Exponential formula (Base=50, Factor=1.25)
    ranks = {
      Name = "Rank",
      ExpName = "Honor",
      RebirthType = "ascension",  -- Which rebirth type to use (set to nil to disable)
      Scaling = { Formula = "Exponential" }
    },

    -- Custom type with INLINE parameters (overrides global Linear)
    stages = {
      Name = "Stage",
      ExpName = "SP",
      RebirthType = "rebirth",  -- Which rebirth type to use (set to nil to disable)
      Scaling = {
        Formula = "Linear",  -- Formula type for calculation logic
        Base = 200,          -- Custom base (overrides global)
        Increment = 75       -- Custom increment (overrides global)
      }
    },

    -- Another custom type with unique exponential scaling
    tiers = {
      Name = "Tier",
      ExpName = "TP",
      RebirthType = "rebirth",  -- Which rebirth type to use (set to nil to disable)
      Scaling = {
        Formula = "Exponential",
        Base = 100,          -- Custom base
        Factor = 1.5         -- Custom factor (faster growth than global)
      }
    },
  },
  Rebirths = {
    enabled = true,
    Types = {
      rebirth   = { Name = "Rebirths",   ShortName = "R" },
      ascension = { Name = "Ascensions", ShortName = "A" },
    },
    -- NOTE: Rebirth mapping is now configured in each level type's RebirthType property above
  },

  -- Global library of scaling formulas; serves as defaults/templates
  -- Types can reference these by name OR provide inline custom parameters
  Scaling = {
    Formulas = {
      Linear = { Base = 100, Increment = 25 },
      Exponential = { Base = 50, Factor = 1.25 },
      -- Add more global formulas here as templates
    },
  },
}
```

### How to add a new level type

**ðŸŽ‰ SIMPLIFIED WORKFLOW - Only 1 step needed!**

1. Add a key under `LevelingConfig.Types` with `Name`, `ExpName`, and `Scaling`.
   - **Option A (Global Formula)**: `Scaling = { Formula = "Linear" }` (uses global params)
   - **Option B (Custom Inline)**: `Scaling = { Formula = "Linear", Base = 200, Increment = 75 }` (custom params)
2. âœ… **Done!** ProfileTemplate automatically populates the type with correct base MaxExp
3. âœ… ProfileSeeder automatically initializes the type in existing player profiles
4. UI can default to a chosen type (e.g., `levels`) or expose a selector.

**Examples:**

```lua
-- Using global formula
prestige = {
  Name = "Prestige",
  ExpName = "Prestige Points",
  RebirthType = "rebirth",  -- or nil to disable rebirth
  Scaling = { Formula = "Exponential" }  -- Uses global Base=50, Factor=1.25
}

-- Custom inline parameters
prestige = {
  Name = "Prestige",
  ExpName = "Prestige Points",
  RebirthType = "ascension",  -- or nil to disable rebirth
  Scaling = {
    Formula = "Exponential",
    Base = 1000,   -- Custom base
    Factor = 2.0   -- Custom growth rate
  }
}
```

### How to change/disable rebirths

- Define family display names under `LevelingConfig.Rebirths.Types`.
- Disable entirely by setting `LevelingConfig.Rebirths.enabled = false` (UI hides, server ignores rebirth features).
- Disable rebirth for a specific level type by setting `RebirthType = nil` in that level type's config.
- Assign a level type to a rebirth family by setting its `RebirthType` property (e.g., `RebirthType = "rebirth"` or `RebirthType = "ascension"`).

## Scaling Formulas (concept)

### Formula Types

- **Linear**: `MaxExp(L) = Base + Increment * (L - 1)`
- **Exponential**: `MaxExp(L) = floor(Base * Factor^(L - 1))`

### Resolution Priority (Fallback Hierarchy)

When calculating MaxExp for a level type, the system uses this priority order:

1. **Inline Custom Parameters** (Highest Priority)

   - If `LevelingConfig.Types[levelType].Scaling` contains `Base` and `Increment` (or `Factor`), use those values
   - Example: `stages` type uses `Base = 200, Increment = 75` instead of global defaults

2. **Global Formula Library** (Fallback)

   - If no inline params, look up `LevelingConfig.Types[levelType].Scaling.Formula` in `LevelingConfig.Scaling.Formulas`
   - Example: `levels` type references `"Linear"` formula, using global `Base = 100, Increment = 25`

3. **Default Linear** (Ultimate Fallback)
   - If neither inline params nor global formula found, use `Base = 100, Increment = 25`

### Implementation

- `Calculator.ResolveFormulaParams(globalFormulas, typeScalingConfig)` handles the fallback hierarchy
- `Calculator.GetNextMaxExp(formulaParams, level)` computes MaxExp using resolved parameters
- Per-type selection via `LevelingConfig.Types[levelType].Scaling`

### Adding Custom Formulas

**Option A: Use Global Formula with Custom Params**

```lua
Types = {
  mytype = {
    Name = "MyType",
    ExpName = "MP",
    Scaling = {
      Formula = "Linear",
      Base = 500,      -- Custom override
      Increment = 100  -- Custom override
    }
  }
}
```

**Option B: Reference Global Formula Template**

```lua
Scaling = {
  Formulas = {
    FastLinear = { Base = 50, Increment = 50 },
  }
}

Types = {
  mytype = {
    Name = "MyType",
    ExpName = "MP",
    Scaling = { Formula = "FastLinear" }  -- Uses global template
  }
}
```

## Profile Integration Details

- All data lives under `ProfileTemplate.Leveling`.
- Example change paths (redirectories arrays used by `ProfileService:ChangeData`):
  - `{ "Leveling", "Types", <levelType>, "Exp" }`
  - `{ "Leveling", "Types", <levelType>, "Level" }`
  - `{ "Leveling", "Types", <levelType>, "MaxExp" }`
  - `{ "Leveling", "Rebirths", <levelType> }`
- `DataController` already streams updates; the client UI binds to those values.

## Client Reading via DataController (example)

The client should derive level/exp/max directly from `DataController.Data`, which is maintained by `ProfileService` via `GetData` and `UpdateSpecificData`.

```lua
-- Example snippet inside a client controller (documentation only)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Knit = require(ReplicatedStorage.Packages.Knit)

local LevelingConfig = require(ReplicatedStorage.SharedSource.Datas.LevelingConfig)

local DataController

local DEFAULT_TYPE = "levels"

local function GetTypeData(levelType)
	local data = DataController and DataController:GetPlayerData()
	if not data or not data.Leveling then return nil end
	local t = data.Leveling.Types[levelType]
	if not t then return nil end
	local names = (LevelingConfig.Types and LevelingConfig.Types[levelType]) or {}
	return levelType, t.Exp, t.MaxExp, t.Level, (data.Leveling.Rebirths[levelType] or 0), names.Name, names.ExpName
end

local function GetExpPercent(levelType)
	local _, exp, maxExp = GetTypeData(levelType or DEFAULT_TYPE)
	if not exp or not maxExp or maxExp <= 0 then return 0 end
	return math.clamp(exp / maxExp, 0, 1)
end

-- In your KnitInit()
-- DataController = Knit.GetController("DataController")
-- In KnitStart(): DataController:WaitUntilProfileLoaded()
-- For re-renders, listen to ProfileService.UpdateSpecificData and/or ProfileService.GetData signals to trigger UI refreshes.

return {
	GetTypeData = GetTypeData,
	GetExpPercent = GetExpPercent,
}
```

### Cleaner Selectors (recommended)

Rather than calling server methods, build small local selectors that always compute from `DataController.Data`. Example display helpers:

```lua
local function GetDisplayHeader(levelType)
	local levelTypeOut, _, _, level, _, typeName = GetTypeData(levelType)
	if not levelTypeOut then return "Loading..." end
	return string.format("%s %d", typeName or levelTypeOut, level or 1)
end

local function GetDisplayExp(levelType)
	local _, exp, maxExp, _, _, _, expName = GetTypeData(levelType)
	exp, maxExp = exp or 0, maxExp or 0
	return string.format("%s / %s %s", tostring(exp), tostring(maxExp), expName or "EXP")
end
```

These selectors can be called from UI render/update functions whenever DataController updates (e.g., on ProfileService.GetData/UpdateSpecificData signals or on a render debounce).

## UI Specification (read-only)

- Data source: `DataController.Data` (via `DataController:GetPlayerData()`); never call server for reads.
- ScreenGui: `LevelUI` (parented to StarterGui; responsive via Scale, no offsets)
- Elements:
  - Header: shows `<Type Name> <Level>` (e.g., "Level 3" or "Rank 3")
  - Progress bar: fill = `Exp / MaxExp`
  - EXP text: `Exp / MaxExp` with number formatting
  - Rebirth label: shows current rebirth count for the displayed type if enabled/mapped
  - Close button: toggles visibility; state can be stored client-side (optional)
- Multi-type support: Display a chosen `levelType` (default to `levels`), or add UI tabs to switch types. Names can be read from `LevelingConfig`.

## Studio Tester Parts (server)

- Folder: `Workspace/LevelSystem_Testers`
- Parts (touch activated, per-player 2s cooldown):

**Row 1 - Basic EXP (levels type):**

1. `+1_EXP` - Adds 1 EXP
2. `+100_EXP` - Adds 100 EXP
3. `+EnoughToLevel` - Adds enough EXP to level up
4. `-1_EXP` - Removes 1 EXP
5. `Set_EXP` - Sets EXP to 500

**Row 2 - Other Types:** 6. `+50_Honor` - Adds 50 Honor (ranks type) 7. `+SP_Stages` - Adds 75 SP (stages type) 8. `+TP_Tiers` - Adds 25 TP (tiers type)

**Row 3 - Rebirths:** 9. `+1_Rebirth_Levels` - Adds 1 Rebirth (levels type) 10. `+1_Ascension_Ranks` - Adds 1 Ascension (ranks type) 11. `Reset_Level_Levels` - Resets level and EXP to starting values (levels type) 12. `Set_Rebirth_Count` - Sets rebirth count to 5 (levels type)

- Behavior is server-only and calls `LevelService` methods directly.

## Shared Utilities

### GetBaseMaxExp

Location: `ReplicatedStorage.SharedSource.Utilities.Levels.GetBaseMaxExp`

Provides functions to calculate base MaxExp values for level types using the formula resolution hierarchy.

**Functions:**

- `GetBaseMaxExp.ForType(levelType)` - Returns base MaxExp for Level 1 of the specified type
- `GetBaseMaxExp.ForAllTypes()` - Returns table of base MaxExp values for all configured types
- `GetBaseMaxExp.GetFormulaParams(levelType)` - Returns resolved formula parameters (Base, Increment/Factor)

**Use Cases:**

- Initializing new level types in profiles
- Validating ProfileTemplate values
- Client-side display calculations
- Admin tools for level type management

### ProfileSeeder

Location: `ReplicatedStorage.SharedSource.Utilities.Levels.ProfileSeeder`

Provides functions to initialize and validate level type data in player profiles.

**Functions:**

- `ProfileSeeder.EnsureAllTypesExist(levelingData)` - Seeds missing types and corrects base MaxExp values
- `ProfileSeeder.ValidateTypeMaxExp(levelingData, levelType)` - Validates base MaxExp for a specific type
- `ProfileSeeder.GetDefaultTypeData(levelType)` - Returns default values for a new type

**Use Cases:**

- Profile initialization on player join
- Adding new level types to existing saves
- Data migration and validation
- Ensuring consistency between config and profile data

**Best Practice:**
Call `ProfileSeeder.EnsureAllTypesExist()` when a player's profile loads to automatically seed any missing level types added to `LevelingConfig` after the profile was created.

**Note:** LevelService automatically calls ProfileSeeder for all players on startup and when new players join.

### BuildProfileTemplate_ForLevel

Location: `ReplicatedStorage.SharedSource.Utilities.Levels.BuildProfileTemplate_ForLevel`

Auto-generates the Leveling section of ProfileTemplate from LevelingConfig.

**Functions:**

- `BuildProfileTemplate_ForLevel.GenerateLevelingData()` - Returns complete Leveling table with Types and Rebirths

**Use Cases:**

- Used by ProfileTemplate to auto-populate level types
- Ensures ProfileTemplate is always in sync with LevelingConfig
- Eliminates manual maintenance of ProfileTemplate

**Benefit:**
Add a new level type? Just update LevelingConfig - ProfileTemplate updates automatically!

## Extension Points

- New level type:
  1. Add to `LevelingConfig.Types` with scaling config
  2. ProfileSeeder will automatically initialize it in player profiles
  3. Calculator and UI already support dynamic types
- New rebirth type: Add to `Types` and `Rebirths.Map`; ensure UI label logic shows the mapped counter.
- New scaling formula: Add to `LevelingConfig.Scaling.Formulas`; select via type's `Scaling.Formula` or provide inline params.

## Acceptance Criteria

- On join, profile has `Leveling.Types.<each configured type>` with `Exp`, `Level`, and `MaxExp` initialized; `Leveling.Rebirths` has counters per type.
- UI derives Level/EXP/MaxEXP strictly from `DataController.Data` (no client RPCs to server).
- Display shows a chosen `levelType` (default `levels`) and updates when data changes.
- Touch testers (if implemented) increase EXP and reflect in UI; `EnoughToLevel` updates `MaxExp` per the selected formula.
- Disabling rebirths in config hides rebirth UI and prevents rebirth counters from changing.
- Persistency: EXP/Level changes survive rejoin under ProfileService.

## Migration & Compatibility

- Previous "active type" fields are deprecated. Remove any `ActiveLevelType` / `ActiveRebirthType` usage from saves and UI. The save now tracks all types concurrently.
- Move display names and per-type formula selection to `LevelingConfig`. Do not store names or formulas in the profile.
- Ensure every configured `levelType` exists under `ProfileTemplate.Leveling.Types[levelType]` and `ProfileTemplate.Leveling.Rebirths[levelType]` with defaults.
- When introducing a new type to existing profiles, seed defaults on player load if the keys are missing.

### Using ProfileSeeder Utility

Use the `ProfileSeeder` utility to automatically seed missing level types:

```lua
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ProfileSeeder = require(ReplicatedStorage.SharedSource.Utilities.Levels.ProfileSeeder)

-- On player profile load:
local _, data = ProfileService:GetProfile(player)
if data and data.Leveling then
	-- Ensures all configured types exist with correct base MaxExp
	local seededTypes = ProfileSeeder.EnsureAllTypesExist(data.Leveling)
	if #seededTypes > 0 then
		print(string.format("[LevelService] Seeded types for %s: %s",
			player.Name,
			table.concat(seededTypes, ", ")))
	end
end
```

### Using GetBaseMaxExp Utility

Calculate base MaxExp for any level type:

```lua
local GetBaseMaxExp = require(ReplicatedStorage.SharedSource.Utilities.Levels.GetBaseMaxExp)

-- Get base MaxExp for a specific type
local levelsMaxExp = GetBaseMaxExp.ForType("levels")  -- Returns 100
local stagesMaxExp = GetBaseMaxExp.ForType("stages")  -- Returns 200 (custom override)

-- Get base MaxExp for all configured types
local allBaseMaxExp = GetBaseMaxExp.ForAllTypes()
-- Returns: { levels = 100, ranks = 50, stages = 200, tiers = 100 }

-- Get formula parameters (advanced)
local formulaParams = GetBaseMaxExp.GetFormulaParams("stages")
-- Returns: { Base = 200, Increment = 75 }
```

## Out of Scope (for now)

- Admin panels, commands, or client-initiated XP modifications.
- Cross-server leaderboards.
- Complex prestige rules (beyond simple rebirth counters).

## Framework Constraints

- Do not modify ReplicatedStorage.SharedSource.Utilities.ScriptsLoader.ComponentsInitializer. Services should call `componentsInitializer(script)` once in `:KnitInit()`.
- Knit lifecycle:
  - Services/Controllers use `:KnitInit()` and `:KnitStart()` (colon syntax).
  - Components (Get/Set/Others) use `.Init()` and `.Start()` (dot syntax) â€” never mix these.
- Only reference real services/controllers that exist in the project; resolve them inside `:KnitInit()` for systems and inside `.Init()` for components.
